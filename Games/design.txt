DESIGN
Robert Collins '20
Harvard, Stoughton Hall
12 / 7 / 16
CS50 Final Project: LED Arcade

Programming for a micro controller like the Arduino introduced some challenges that were new to me, like dealing with limited memory and ensuring compatibility with different configurations. Thankfully, the C++ language that is used when programming for Arduinos using the software suite is very similar to C, which I had experience with from the CS50 curriculum. This document will explain the design decisions I made while creating this project.

General
In previous projects I have worked on, it was easy to separate different sections of the project into distinct files and sections. However, micro controllers do not afford this luxury. The Arduino runs a single method "startup" on startup, and a loops a single method "loop" continuously. Thus, I had to design a way to load different "modes" onto the LED strip, and effectively run multiple Arduino sketches in a single sketch. To do this, I created a different startup and loop method for each mode, and ran a switch statement inside the main loop() method that ran a different method based on the state of a variable I created. This software switch allowed me to seamlessly transition from mode to mode, within a single Arduino sketch.

A feature of the Arduino compiler is that any files with a .ino suffix within the same directory are concatenated into a single file before compilation. This allowed me to separate out different sections of the project into distinct files. In addition, because all the .ino files are treated by the compiler as a single file, I tried to reuse as many variables and methods as I could between sections. Most of the reused variables and methods can be found in globals.h or in helpers.ino. This saves memory, but occasionally makes the code difficult to understand.

Throughout this project, I tried to use the #define keyword to define as many constants as I could. This allowed me to tweak and configure my code at ease, especially while debugging or testing different configurations. It also makes the code much easier to read and interpret. In addition, I tried to make this project adaptable for different hardware configurations. For example, the library I used, FastLED, can drive many different kinds of addressable LED strips, simply by changing a single keyword. I recognized that myself or another user may want to play the games on a vertical strip, or with the joystick pointing a different way, so I designed the joystick code to account for this, with an easily changed constant (WIRE_DIRECTION) defining the orientation.

A major challenge I ran into while trying to program motion on the strip was trying to make motion appear smooth and natural when controlled by the joystick. The LED strip offers very limited resolution, so slow movement appeared choppy, while fast motion was difficult to control. In addition, the small joysticks I used have very limited resolutions, so programming fine control was hard. I experimented with variable FPS settings, using a velocity value, and varying speed levels. In the end, I found the only simple, reliable method was to treat the joystick as a panel of four buttons. The treatValue() method converts the raw joystick data, which ranges from 0 to 1023, to a treated value of either -1, 0, or 1. These values are stored as signed char values, so they only take up a single byte of storage, compared to the 16 required by an int.

Menu
Designing a menu is clear and intuitive proved to be somewhat of a challenge. The LED strip can't convey much information, so I had to be creative in how I displayed each game. I elected to use small patterns to distinguish between the games in the menu. Each represents a small snippet of the game being played. These patterns are stored using strings, in which spaces represent black LEDs, and the letters rgby represent colors. This was more space efficient than storing arrays of colors, and allowed easy adjustment of the patterns during development. In order to make the menu smooth, I incorporated a delay that would briefly pause the selector between movements. This slowed down the menu UI and made it much more usable.

Gun Game
gunGame.ino is by far the largest and most complex file within the project. The game requires many moving entities that each need to be updated individually with each frame. To allow this, I defined three separate types of entities that would be be on the strip: the player dot, gun particles, and enemies. The player dot is also used in pong and react, so it's information is defined in globals.h. The enemies and gun particles are defined using structs, and then an array containing multiple copies of the struct is created. I then wrote two functions, updateGuns() and updateEnemies(), which iterate through their respective arrays each frame and update the position and other aspects of each entity. All collision detection is done within the updateEnemies() function, as the only collisions that matter are those between enemies and other entities.

It's possible that the various functions that draw onto the LED strip would draw to the same location, so I had to establish a hierarchy of importance. The trail behind the player is least important, then gun particles, then enemies, and the player dot overwrites everything. The code drawing each entity to the strip is located within gunLoop() according to this hierarchy: updateTrail() first, then updateGuns(), updateEnemies(), and finally the line that draws the player dot.

Pong
Pong proved to be a much simpler game than the Gun Game. However, I used many similar methods to implement it. The new moving entity, ball, gets it's own struct, and the wall is defined by a series of constants, an array, and an int. The updateBall() function moves the ball around the strip and checks for collisions, while the updateWall() function redraws the wall each frame, and shifts the wallFront variable if the previous section has been destroyed. Separating out the entity-specific logic makes the pongLoop() function very short, only containing code controlling the player dot.

A key element of playing Pong on the LED strip is matching the color of the player dot with the color of the ball. Color matching is a deceptively difficult problem to solve, as color is defined using three dimensions. By using HSV colors instead of RGB colors, I was able to ignore two of these dimensions, and only focus on the hue of the color. Hue is defined as the angle around the color wheel, so I adapted an equation for finding the distance between angles to use angles from 0-255, and then verified that this distance was within a specified tolerance. This logic can be found within the colorsMatch() function at the end of pong.ino.

React
React is an even simpler game than Pong. I reused many variables, like dot, dotColor, and deathTime, in order to save space. I had to adjust my usual trail algorithm to work with faster moving entities. Usually, the trail code adds the current position of the dot at each frame to the trail array, which is then colored. However, if an entity is skipping over LEDs between frames, the trail code must compensate for that by filling in all the leds between frames. This is accomplished by placing the trail code within the location updating code of the dot, and using the dot and newPos variables as the bounds of the area to be filled in.

FastLED Library
There are a number of different libraries available to drive addressable LED strips. However, I found that Daniel Garcia's FastLED library provided the right amount of utility without adding too much overhead to the project. The FastLED library is optimized to use as little memory and processing power as possible, as it's designed to be used on micro controllers like the the Arduino. In addition, the FastLED library contains useful features like a fast pseudo random number generator, fast sine wave functions, and conversion between RGB and HSV color spaces.

The color functions were extremely useful throughout the project. I primarily used HSV colors, as I was often dealing with changing hues and brightness, not with changing levels of shades. However, a limitation of the FastLED library is that it only provides conversions from HSV to RGB, and not the other way around. Thus, I often had to use variables to store HSV colors before adding them to the strip. The dotColor variable and trail array are examples of this.

Summary
Programming for a micro controller was a new challenge for me, and forced me to program more carefully and slowly than I usually do. As the Arduino lacks native debugging capability, I had to rely on serial print statements to get variable information to fix errors. In addition, I had to be careful about memory and processor usage, as the Arduino has much less memory and processor power than computers I am used to programming with. Overall, I'm pleased with the outcome of my project, and will likely try to expand on it in the future.
